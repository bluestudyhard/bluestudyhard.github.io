[toc]

## 大前提 关于 url 的介绍

URL - Uniform Resource Locator 统一资源定位符 即网址 即访问的目标

### URL 的组成

一个 url 的常用格式包括：
**所用协议://访问的服务器地址/服务器的文件目录/文件目录上的文件夹/目标文件**

完整格式包括：
**所用协议://用户名:密码 访问的服务器地址:端口号(默认 80)/服务器的文件目录/文件目录上的文件夹/目标文件**

- 以网址 `http://www.w3school.com.cn/html/index.php` 为例

![img](webimg/urlformat.png)

**访问 URL 时省略**
我们经常可以见到类似于
www.bilibili.com 这样的网址 或者是 www.baidu.com/ 其实是省略了后面的文件名。

省略掉后面的文件名时 例如`https://www.bilibili.com/`，**/ 表示**的是省略后的文件夹。所以这种形式的访问的是默认的，事先在服务器上设置好的文件名。
如果 https://www.bilibili.com 这样的话连 / 都省略了，就代表，访问的根目录下设置的默认文件，即主页。
https://www.bilibili.com/wtf 如果是这种，在文件目录下没有存在 wtf.html 目录就按目录创建，存在就当成文件。

### URL 中的特殊字符

(https://blog.csdn.net/zlingyun/article/details/83536589)
(https://blog.csdn.net/u011600592/article/details/82730989)

![img](webimg/url.png)
![img](webimg/url1.png)

**使用特殊字符的原因**
如果你的表单使用 get 方法提交，并且提交的参数中有“&”等特殊符的话，如果不做处理，在 service 端就会将&后面的作为另外一个参数来看待

例如
表单的 action 为 **list.jsf?act=go&state=5**。则提交时通过 **request.getParameter** 可以分别取得 act 和 state 的值。
如果你的本意是 **act='go&state=5'**这个字符串，那么为了在服务端拿到 act 的准确值，你必须对&进行转义。

**url 转义字符原理：**
将这些特殊的字符转换成 ASCII 码，格式为：**%加字符的 ASCII 码**

在 url 中空格是无法直接表示的，所以如果要打空格，可以用 + 或者用 `%20` 来表示

**URL 特殊符号及对应的十六进制值编码：**

```js {.line-numbers}


 +       URL中+号表示空格                  %2B
 空格     URL中的空格可以用+号或者编码        %20
 /       分隔目录和子目录                   %2F
 ?       分隔实际的 URL 和参数              %3F
 %       指定特殊字符                      %25
 #       表示书签                         %23
 &       URL中指定的参数间的分隔符           %26
 =       URL中指定参数的值                 %3D
```

**?**
**1、连接作用(最常用)**
**用于连接一些参数，分隔离实际的 url 和参数**

比如说 `https://cn.bing.com/search?q=url` ?后面连接的 q 就是一个参数，然后也是和原本要访问的`https://cn.bing.com/search` 分割开来

2、清除缓存

```js {.line-numbers}
http://www.xxxxx.com/index.html
http://www.xxxxx.com/index.html?test123123
```

两个 url 打开的页面一样，但是后面这个有问号，说明不调用缓存的内容，而认为是一个新地址，重新读取。

**&**
用于分割参数

```js {.line-numbers}
http://www.xxxxx.com/index.html?test123123&id=blue
```

**#**
这玩意一堆作用后面再补

## 前后端通信

前后端通信本质上就是

- 前端和后端数据交互的过程
- 浏览器和服务器直接数据交互的过程。
  前端的基本理解
  前端就是客户端，移动端，等我们作为 user 可以直接看到的页面。

### 前后端通信的过程，方式

- 前后端的通信是在请求-响应中完成的
  浏览器请求数据，而服务器返回响应数据

- 浏览器发送请求分为以下几个步骤
  对 url 进行解析

- 使用 ajax 和 fetch 进行通信

- 解析 HTML 的标签的时候遇到一些特殊的标签
  `link / img / script / iframe` 会再次向服务器发送请求
  还有 `a /form`这样的标签，浏览器解析时不会主动向服务器发送请求，但是用户可以手动发送请求。

- WebSocket

### http 协议

详见网络是怎样连接的.md

### API

#### API 的基本概念

API Application Programming Interface
简单来说就是 程序之间的接口。

这个接口，其实就像现成的工具一样，不需要我们做什么事情，我们只需要根据我们的需求，利用这个 api 来实现一些操作就可以了。
举个例子，我需要请人帮我做家务，我需要叫家政公司为我提供服务，在这里，家政公司就是 API。 而怎么请阿姨，阿姨的打扫方法，都不是我需要考虑的。我需要做的只是，表明我的需求，她需要打扫卧室啊，什么的就可以了。
**也就是说 API 的实现细节，很多时候我们是不需要知道的。**

- 下图表示在前后端直接 API 的作用
  ![img](webimg/api.png)

#### 现在 API 最常用的形式——以网络请求为基础的 API

![img](webimg/api-relationship.webp)

### Cookie

[可以康康这篇](https://www.jianshu.com/p/6fc9cea6daa2/)

#### Cookie 介绍

百度百科定义：
Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 [1]
现代 js 定义：
Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分，由 RFC 6265 规范定义。
Cookie 通常是由 Web 服务器使用响应 Set-Cookie HTTP-header 设置的。然后浏览器使用 Cookie HTTP-header 将它们自动添加到（几乎）每个对相同域的请求中。

- Cookie 是一个储存 key value 属性的文本文件 用于储存用户访问某些网站时的个人信息。
  http 协议本身是无状态的，那么服务器如何判断访问的用户信息，靠的就是 Cookie
  当我们第一次访问一个网站时，我们对服务器进行第一次请求，服务器会发送一个 Cookie 储存到本地，然后下次访问时，http 协议就会携带这个 Cookie 来请求，这样服务器返回的就是带有个人信息的请求。

下图形象的描绘了客户端和服务器之间是如何传输 Cookie 的
!img()

**Cookie 用法**
Cookie 最常见的用法就是身份验证。

### 同步 异步 阻塞 非阻塞 io

[介个](https://zhuanlan.zhihu.com/p/88403724)

#### 同步

同步，顾名思义同步进行。
比如说客户端向服务器请求，比如说执行一个功能调用，在等待服务器返回消息的过程中，请求方是不能做任何事情的，要等待返回了消息以后，才可以继续下一次请求。
**举个例子，小明下载东西，他只能等待进度条到百分之 100，才可以继续下载下一个。**

#### 异步

异步，不用同步进行。
异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。

对于通知调用者的三种方式，具体如下：

状态
即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。

通知
当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。

回调
与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。

例如：B/S 模式中的 ajax 请求，具体过程是：客户端发出 ajax 请求->服务端处理->处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。

**举个栗子，小明下载东西他可以同时下载好几个，但是由于他没有看到一个先下载好，所以他要反复的确认下载进度。这就是轮询**

- **轮询** 以后细说

#### 阻塞

阻塞/非阻塞是与线程有关的，关注的是等待调用结果时的状态。
就像cin，scanf输入那样，你不输入，输入流永远是阻塞的，线程被挂起了。



阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
**异步阻塞**
异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明不做别的事，仍然一直等待“叮”的声音。 - 异步体现在：下载完成“叮”一声通知。 - 阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理。
**同步阻塞**

#### 非阻塞

**异步非阻塞**
异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。 - 异步体现在：下载完成“叮”一声通知。 - 非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可。【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】

#### io

IO 是 input 和 output
