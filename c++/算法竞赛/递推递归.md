##卡特兰数
####递归的tips
递归就是不断的调用自己，条件有，起始段，前进段，以及终止条件，终止就是边界。例如，斐波那契数列，起始段就是，f(1) = 1,f(2) = 1;终止条件就是，前进条件就是n！=1或2，终止边界就是1or2
```C++ {.line-numbers} 
#include <bits/stdc++.h>
using namespace std;
int f[5000],i,j;
int main()
{   //卡特兰数做法
    //卡特兰的核心 f[n] = f[0]*f[n-1]+f[1]*f[n-2]+...f[n-1]*f[0];
    //例 f[3] = f[2]*f[0]+f[1]*f[1]+f[0]*f[2];
    
    int n;
    cin>>n;
    f[1] = f[0] = 1;
    for(i = 2;i<=n;i++)
    {
        for(j = 0;j<i;j++)
        {
            f[i]+=f[j]*f[i-1-j];
        }
    }
    cout<<f[n];
}
```
###卡特兰组合数做法
```C++ {.line-numbers} 
#include <bits/stdc++.h>
using namespace std;
//卡特兰数最好公式 h[n] = c[2n][n]-c[2n][n-1];
//组合数公式 c[i][j] = c[i-1][j]+c[i-1][j-1];
long long c[10000][5000], i, j;
int main()
{
    int n;
    cin >> n;
    for (i = 1; i <= 2 * n; i++)
    {
        c[i][0] = c[i][i] = 1;
        for (j = 1; j < i; j++)
        {
            c[i][j] = c[i - 1][j] + c[i-1][j - 1];
            //先i-1的原因是，如果是i先的话，在i=1时，c11 = 2了
             // c(2,1) = c(1,0)+c(2,0);
        }
    }
    printf("%lld", c[2 * n][n] - c[2 * n][n - 1]);
}
```