[toc]

### 位运算的基本操作符

- & 运算符
- 两个位都为 1 取 1，否则取 0
- | 运算符
- 两个位都为 0 时，结果才为 0
- ~ 取反，就是把数都反过来
- &1 的意思可以理解为%2 判断偶数，与 1 取与后，
- ( **>>** ) 左移，表示整个 2 进制往后移动 1 位 相当于int number/2
- **比如 >>2 == >>0011 = 0001;**
- 具体见真值表
- ![img](C:/vscode/算法竞赛/img/例.jpg)

## 进制转换

- 十进制转二进制 原理如图
- ![img](C:/vscode/算法竞赛/img/10转2.png)
- 代码实现

```C++ {.line-numbers}
 vector <int> ans;
    int n;
    cin>>n;
    while(n)//
    {
        ans.push_back(n&1),n>>=1;

    }
    reverse(ans.begin(),ans.end());
    for(i = 1;i<=ans.size();i++)
    cout<<ans[i];
```

### 有趣的 bitset

- 相当于生成一个二进制的字节空间
- `bitset<4> k` 这个生成的是一个四个字符的字节空间
- bitset 的一些有趣函数

```C++ {.line-numbers}
bitset<8> foo ("10011011");

    cout << foo.count() << endl;　　//5　　（count函数用来求bitset中1的位数，foo中共有５个１
    cout << foo.size() << endl;　　 //8　　（size函数用来求bitset的大小，一共有８位
    cout << foo.test(0) << endl;　　//true　　（test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回true
    cout << foo.test(2) << endl;　　//false　　（同理，foo[2]为０，返回false

    cout << foo.any() << endl;　　//true　　（any函数检查bitset中是否有１
    cout << foo.none() << endl;　　//false　　（none函数检查bitset中是否没有１
    cout << foo.all() << endl;　　//false　　（all函数检查bitset中是全部为１
```

- 小小例题 from acwing
- 求数组中数的二进制中 1 的个数

```C++ {.line-numbers}
    int T, n;
    for (cin >> T; T--;)
    {
        int ans = 0;
        cin >> n;
        bitset<16> t(n);
        cout << t.count() << " ";
    }
    一般做法
    int ans(int n)
    {
        int sum = 0;
        while(n)
        {
            if(n&1)
            sum++;
            n>>=1;
        }
        return sum;
    }
      5
  in  1 2 3 4 5
  out 1 1 2 1 2
```

### 常识

-     1bit = 8byte byte是最小的储存单位，表示字节。
-     1mb = 1024kb = 1024*1024bit = 1024*1024*8byte
-     256 mb = 67,108,864byte;

## 好sword的进制转换 (特性)
    int s;
    cin>>hex>>s;
    cout<<dec<<s;//转10进制
    cout<<oct<<s<<endl;//转八进制
    
### 统计x进制中的1
```C++ {.line-numbers} 
int prime(int n,int x)
{   
    int sum = 0;
    while(n)
    {
        if(n%x==1)
            sum++;
        n/=x;
    }
 return sum;
}
```